[[mongo.jsonSchema]]
=== JSON Schema

As of version 3.6, MongoDB supports collections that validate documents against a provided https://docs.mongodb.com/manual/core/schema-validation/#json-schema[JSON Schema].
The schema itself and both validation action and level can be defined when creating the collection, as the following example shows:

.Sample JSON schema
====
[source,json]
----
{
  "type": "object",                                                        <1>

  "required": [ "firstname", "lastname" ],                                 <2>

  "properties": {                                                          <3>

    "firstname": {                                                         <4>
      "type": "string",
      "enum": [ "luke", "han" ]
    },
    "address": {                                                           <5>
      "type": "object",
      "properties": {
        "postCode": { "type": "string", "minLength": 4, "maxLength": 5 }
      }
    }
  }
}
----
<1> JSON schema documents always describe a whole document from its root. A schema is a schema object itself that can contain
embedded schema objects that describe properties and subdocuments.
<2> `required` is a property that describes which properties are required in a document. It can be specified optionally, along with other
schema constraints. See MongoDB's documentation on https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/#available-keywords[available keywords].
<3> `properties` is related to a schema object that describes an `object` type. It contains property-specific schema constraints.
<4> `firstname` specifies constraints for the `firsname` field inside the document. Here, it is a string-based `properties` element declaring
 possible field values.
<5> `address` is a subdocument defining a schema for values in its `postCode` field.
====

You can provide a schema either by specifying a schema document (that is, by using the `Document` API to parse or build a document object) or by building it with Spring Data's JSON schema utilities in `org.springframework.data.mongodb.core.schema`. `MongoJsonSchema` is the entry point for all JSON schema-related operations. The following example shows how use `MongoJsonSchema.builder()` to create a JSON schema:

.Creating a JSON schema
====
[source,java]
----
MongoJsonSchema.builder()                                                    <1>
    .required("lastname")                                                    <2>

    .properties(
                required(string("firstname").possibleValues("luke", "han")), <3>

                object("address")
                     .properties(string("postCode").minLength(4).maxLength(5)))

    .build();                                                                <4>
----
<1> Obtain a schema builder to configure the schema with a fluent API.
<2> Configure required properties either directly as shown here or with more details as in 3.
<3> Configure the required String-typed `firstname` field, allowing only `luke` and `han` values. Properties can be typed or untyped. Use a static import of  `JsonSchemaProperty` to make the syntax slightly more compact and to get entry points such as `string(â€¦)`.
<4> Build the schema object. Use the schema to create either a collection or <<mongodb-template-query.criteria,query documents>>.
====

There are already some predefined and strongly typed schema objects (`JsonSchemaObject` and `JsonSchemaProperty`) available
through static methods on the gateway interfaces.
However, you may need to build custom property validation rules, which can be created through the builder API, as the following example shows:

[source,java]
----
// "birthdate" : { "bsonType": "date" }
JsonSchemaProperty.named("birthdate").ofType(Type.dateType());

// "birthdate" : { "bsonType": "date", "description", "Must be a date" }
JsonSchemaProperty.named("birthdate").with(JsonSchemaObject.of(Type.dateType()).description("Must be a date"));
----

`CollectionOptions` provides the entry point to schema support for collections, as the following example shows:

.Create collection with `$jsonSchema`
====
[source,java]
----
MongoJsonSchema schema = MongoJsonSchema.builder().required("firstname", "lastname").build();

template.createCollection(Person.class, CollectionOptions.empty().schema(schema));
----
====

[[mongo.jsonSchema.generated]]
==== Generating the Schema

Setting up a schema can be a time consuming task and we encourage everyone who decides to do so, to really take the time
it takes. It's important, schema changes can be hard. However there might be times when one does not want to balked
with it, and that is where the `JsonSchemaCreator` comes into play.

The `JsonSchemaCreator` and its default implementation generate the `MongoJsonSchema` out of the domain types metadata provided
by the mapping infrastructure. This means that <<mapping-usage-annotations, annotated properties>> as well as potential <<mapping-configuration, custom conversions>>
are considered.

.Generate Json Schema from domain type
====
[source,java]
----
public class Person {

    private final String firstname; <1>
    private final @Nullable String lastname; <2>
    private int age; <3>
    private Species species; <4>
    private Address address; <5>
    private @Field(fieldType=SCRIPT) String theForce; <6>
    private @Transient Boolean useTheForce; <7>

    public Person(String firstname, @Nullable String lastname) { <1> <2>

        this.firstname = firstname;
        this.lastname = lastname;
    }

    // gettter / setter omitted
}

MongoJsonSchema schema = schemaCreator.jsonSchemaCreator(mongoOperations.getConverter())
    .createSchemaFor(DomainType.class);

template.createCollection(Person.class, CollectionOptions.empty().schema(schema));
----

[source,json]
----
{
    'type' : 'object',
    'required' : ['firstname', 'age'], <1> <3>
    'properties' : {
        'firstname' : { 'type' : 'string' }, <1>
        'lastname' : { 'type' : 'string' }, <2>
        'age' : { 'bsonType' : 'int' } <3>
        'species' : { <4>
            'type' : 'string',
            'enum' : ['HUMAN', 'WOOKIE', 'UNKNOWN']
        }
        'address' : { <5>
            'type' : 'object'
            'properties' : {
                'postCode' : { 'type': 'string' }
            }
        },
        'theForce' : { 'type' : 'javascript'} <6>
     }
}
----
<1> Required property as **not** `@Nullable` and used in the constructor.
<2> Optional property though used in the constructor it is still `@Nullable`.
<3> Primitive types are considered required properties.
<4> Enums are restricted to possible values.
<5> Object type properties get are inspected themselfes.
<6> `String` type property that is truned into `Code` by the mapping.
<7> `@Transient` properties are left out when generating the schema.
====

NOTE: `_id` properties using types that can be converted into `ObjectId` like `String` are mapped to `{ type : 'object' }`
unless there is more specific information available via the `@MongoId` annotation.

[cols="3,1,6", options="header"]
.Sepcial Schema Generation rules
|===
| Java
| Schema Type
| Notes

| `Object`
| type : object
| with `properties` if metadata available.

| `Collection`
| type : array
| -

| `Map`
| type : object
| -

| `Enum`
| type : string
| with `enum` property holding the possible enumeration values.

| `array`
| type : array
| simple type array unless it's a `byte[]`

| `byte[]`
| bsonType : binData
| -

|===

[[mongo.jsonSchema.query]]
==== Query a collection for matching Json Schema

You can use a schema to query any collection for documents that match a given structure defined by a JSON schema, as the following example shows:

.Query for Documents matching a `$jsonSchema`
====
[source,java]
----
MongoJsonSchema schema = MongoJsonSchema.builder().required("firstname", "lastname").build();

template.find(query(matchingDocumentStructure(schema)), Person.class);
----
====

[[mongo.jsonSchema.types]]
==== Json Schema Types

The following table shows the supported JSON schema types:

[cols="3,1,6", options="header"]
.Supported JSON schema types
|===
| Schema Type
| Java Type
| Schema Properties

| `untyped`
| -
| `description`, generated `description`, `enum`, `allOf`, `anyOf`, `oneOf`, `not`

| `object`
| `Object`
| `required`, `additionalProperties`, `properties`, `minProperties`, `maxProperties`, `patternProperties`

| `array`
| any array except `byte[]`
| `uniqueItems`, `additionalItems`, `items`, `minItems`, `maxItems`

| `string`
| `String`
| `minLength`, `maxLentgth`, `pattern`

| `int`
| `int`, `Integer`
| `multipleOf`, `minimum`, `exclusiveMinimum`, `maximum`, `exclusiveMaximum`

| `long`
| `long`, `Long`
| `multipleOf`, `minimum`, `exclusiveMinimum`, `maximum`, `exclusiveMaximum`

| `double`
| `float`, `Float`, `double`, `Double`
| `multipleOf`, `minimum`, `exclusiveMinimum`, `maximum`, `exclusiveMaximum`

| `decimal`
| `BigDecimal`
| `multipleOf`, `minimum`, `exclusiveMinimum`, `maximum`, `exclusiveMaximum`

| `number`
| `Number`
| `multipleOf`, `minimum`, `exclusiveMinimum`, `maximum`, `exclusiveMaximum`

| `binData`
| `byte[]`
| (none)

| `boolean`
| `boolean`, `Boolean`
| (none)

| `null`
| `null`
| (none)

| `objectId`
| `ObjectId`
| (none)

| `date`
| `java.util.Date`
| (none)

| `timestamp`
| `BsonTimestamp`
| (none)

| `regex`
| `java.util.regex.Pattern`
| (none)

|===

NOTE: `untyped` is a generic type that is inherited by all typed schema types. It provides all `untyped` schema properties to typed schema types.

For more information, see https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/#op._S_jsonSchema[$jsonSchema].
